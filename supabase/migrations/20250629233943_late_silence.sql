/*
  # Database Schema Alignment Fix

  1. Schema Updates
    - Add missing columns to shower_thoughts table
    - Create interactions table for proper tracking
    - Add performance indexes
    
  2. Functions
    - increment_thought_views: Track and increment view counts
    - toggle_thought_like: Handle like/unlike functionality
    - increment_thought_shares: Track share interactions
    - update_user_presence: Track online user presence
    - get_thought_stats: Get comprehensive thought statistics
    
  3. Security
    - Enable RLS on new tables
    - Create appropriate policies for data access
    - Grant necessary permissions
*/

-- Add missing columns to shower_thoughts table
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'shower_thoughts' AND column_name = 'views_count') THEN
    ALTER TABLE shower_thoughts ADD COLUMN views_count integer DEFAULT 0;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'shower_thoughts' AND column_name = 'likes_count') THEN
    ALTER TABLE shower_thoughts ADD COLUMN likes_count integer DEFAULT 0;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'shower_thoughts' AND column_name = 'shares_count') THEN
    ALTER TABLE shower_thoughts ADD COLUMN shares_count integer DEFAULT 0;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'shower_thoughts' AND column_name = 'category') THEN
    ALTER TABLE shower_thoughts ADD COLUMN category text;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'shower_thoughts' AND column_name = 'tags') THEN
    ALTER TABLE shower_thoughts ADD COLUMN tags text[] DEFAULT '{}';
  END IF;
END $$;

-- Add indexes for performance (only if they don't exist)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_shower_thoughts_views_count') THEN
    CREATE INDEX idx_shower_thoughts_views_count ON shower_thoughts(views_count DESC);
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_shower_thoughts_likes_count') THEN
    CREATE INDEX idx_shower_thoughts_likes_count ON shower_thoughts(likes_count DESC);
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_shower_thoughts_category') THEN
    CREATE INDEX idx_shower_thoughts_category ON shower_thoughts(category);
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_shower_thoughts_tags') THEN
    CREATE INDEX idx_shower_thoughts_tags ON shower_thoughts USING GIN(tags);
  END IF;
END $$;

-- Create interactions table if it doesn't exist
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'interactions') THEN
    CREATE TABLE interactions (
      id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
      thought_id uuid REFERENCES shower_thoughts(id) ON DELETE CASCADE,
      interaction_type text NOT NULL CHECK (interaction_type IN ('like', 'view', 'share')),
      created_at timestamptz DEFAULT now(),
      UNIQUE(user_id, thought_id, interaction_type)
    );
  END IF;
END $$;

-- Enable RLS on interactions table
DO $$ 
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'interactions') THEN
    ALTER TABLE interactions ENABLE ROW LEVEL SECURITY;
  END IF;
END $$;

-- Drop existing policies if they exist and recreate them
DO $$ 
BEGIN
  -- Drop policies if they exist
  DROP POLICY IF EXISTS "Users can manage own interactions" ON interactions;
  DROP POLICY IF EXISTS "Users can view public interactions" ON interactions;
  
  -- Create new policies
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'interactions') THEN
    CREATE POLICY "Users can manage own interactions" ON interactions
      FOR ALL TO authenticated
      USING (auth.uid() = user_id)
      WITH CHECK (auth.uid() = user_id);

    CREATE POLICY "Users can view public interactions" ON interactions
      FOR SELECT TO authenticated
      USING (true);
  END IF;
END $$;

-- Add indexes for interactions (only if they don't exist)
DO $$ 
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'interactions') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_interactions_user_id') THEN
      CREATE INDEX idx_interactions_user_id ON interactions(user_id);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_interactions_thought_id') THEN
      CREATE INDEX idx_interactions_thought_id ON interactions(thought_id);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_interactions_type') THEN
      CREATE INDEX idx_interactions_type ON interactions(interaction_type);
    END IF;
  END IF;
END $$;

-- Create or replace function to increment thought views
CREATE OR REPLACE FUNCTION increment_thought_views(thought_id uuid)
RETURNS integer AS $$
DECLARE
  new_count integer;
  current_user_id uuid;
BEGIN
  -- Get current user ID
  current_user_id := auth.uid();
  
  -- Only track views if user is authenticated and interactions table exists
  IF current_user_id IS NOT NULL AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'interactions') THEN
    -- Insert or update view interaction
    INSERT INTO interactions (user_id, thought_id, interaction_type)
    VALUES (current_user_id, thought_id, 'view')
    ON CONFLICT (user_id, thought_id, interaction_type) 
    DO UPDATE SET created_at = now();
  END IF;
  
  -- Update the views count in shower_thoughts
  UPDATE shower_thoughts 
  SET views_count = COALESCE(views_count, 0) + 1
  WHERE id = thought_id
  RETURNING views_count INTO new_count;
  
  RETURN COALESCE(new_count, 0);
EXCEPTION
  WHEN OTHERS THEN
    -- If there's an error, just return current count
    SELECT COALESCE(views_count, 0) INTO new_count
    FROM shower_thoughts 
    WHERE id = thought_id;
    
    RETURN COALESCE(new_count, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create or replace function to toggle thought likes
CREATE OR REPLACE FUNCTION toggle_thought_like(thought_id uuid, user_id uuid)
RETURNS integer AS $$
DECLARE
  new_count integer;
  interaction_exists boolean;
BEGIN
  -- Check if interactions table exists
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'interactions') THEN
    -- Fallback: just return current count
    SELECT COALESCE(likes_count, 0) INTO new_count
    FROM shower_thoughts 
    WHERE id = thought_id;
    RETURN COALESCE(new_count, 0);
  END IF;
  
  -- Check if user has already liked this thought
  SELECT EXISTS(
    SELECT 1 FROM interactions 
    WHERE interactions.user_id = toggle_thought_like.user_id 
    AND interactions.thought_id = toggle_thought_like.thought_id 
    AND interaction_type = 'like'
  ) INTO interaction_exists;
  
  IF interaction_exists THEN
    -- Remove like
    DELETE FROM interactions 
    WHERE interactions.user_id = toggle_thought_like.user_id 
    AND interactions.thought_id = toggle_thought_like.thought_id 
    AND interaction_type = 'like';
    
    -- Decrement likes count
    UPDATE shower_thoughts 
    SET likes_count = GREATEST(COALESCE(likes_count, 0) - 1, 0)
    WHERE id = thought_id
    RETURNING likes_count INTO new_count;
  ELSE
    -- Add like
    INSERT INTO interactions (user_id, thought_id, interaction_type)
    VALUES (user_id, thought_id, 'like');
    
    -- Increment likes count
    UPDATE shower_thoughts 
    SET likes_count = COALESCE(likes_count, 0) + 1
    WHERE id = thought_id
    RETURNING likes_count INTO new_count;
  END IF;
  
  RETURN COALESCE(new_count, 0);
EXCEPTION
  WHEN OTHERS THEN
    -- If there's an error, just return current count
    SELECT COALESCE(likes_count, 0) INTO new_count
    FROM shower_thoughts 
    WHERE id = thought_id;
    
    RETURN COALESCE(new_count, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create or replace function to increment shares
CREATE OR REPLACE FUNCTION increment_thought_shares(thought_id uuid)
RETURNS integer AS $$
DECLARE
  new_count integer;
  current_user_id uuid;
BEGIN
  -- Get current user ID
  current_user_id := auth.uid();
  
  -- Only track shares if user is authenticated and interactions table exists
  IF current_user_id IS NOT NULL AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'interactions') THEN
    -- Insert share interaction
    INSERT INTO interactions (user_id, thought_id, interaction_type)
    VALUES (current_user_id, thought_id, 'share')
    ON CONFLICT (user_id, thought_id, interaction_type) 
    DO UPDATE SET created_at = now();
  END IF;
  
  -- Update the shares count in shower_thoughts
  UPDATE shower_thoughts 
  SET shares_count = COALESCE(shares_count, 0) + 1
  WHERE id = thought_id
  RETURNING shares_count INTO new_count;
  
  RETURN COALESCE(new_count, 0);
EXCEPTION
  WHEN OTHERS THEN
    -- If there's an error, just return current count
    SELECT COALESCE(shares_count, 0) INTO new_count
    FROM shower_thoughts 
    WHERE id = thought_id;
    
    RETURN COALESCE(new_count, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create or replace function to update user presence (for realtime features)
CREATE OR REPLACE FUNCTION update_user_presence(
  presence_status text DEFAULT 'online',
  page_location text DEFAULT '/'
)
RETURNS void AS $$
DECLARE
  current_user_id uuid;
BEGIN
  -- Get current user ID
  current_user_id := auth.uid();
  
  IF current_user_id IS NULL THEN
    RETURN;
  END IF;
  
  -- Only update if online_users table exists
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'online_users') THEN
    -- Update or insert user presence
    INSERT INTO online_users (user_id, status, current_page, last_seen, updated_at)
    VALUES (current_user_id, presence_status, page_location, now(), now())
    ON CONFLICT (user_id) 
    DO UPDATE SET 
      status = EXCLUDED.status,
      current_page = EXCLUDED.current_page,
      last_seen = now(),
      updated_at = now();
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create or replace function to get thought statistics
CREATE OR REPLACE FUNCTION get_thought_stats(thought_id uuid)
RETURNS TABLE(
  views_count integer,
  likes_count integer,
  shares_count integer,
  comments_count integer
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(st.views_count, 0) as views_count,
    COALESCE(st.likes_count, 0) as likes_count,
    COALESCE(st.shares_count, 0) as shares_count,
    COALESCE((
      SELECT COUNT(*)::integer 
      FROM comments 
      WHERE comments.thought_id = get_thought_stats.thought_id
    ), 0) as comments_count
  FROM shower_thoughts st
  WHERE st.id = get_thought_stats.thought_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update existing shower_thoughts to have proper default values
UPDATE shower_thoughts 
SET 
  views_count = COALESCE(views_count, 0),
  likes_count = COALESCE(likes_count, 0),
  shares_count = COALESCE(shares_count, 0),
  tags = COALESCE(tags, '{}')
WHERE views_count IS NULL 
   OR likes_count IS NULL 
   OR shares_count IS NULL 
   OR tags IS NULL;

-- Grant necessary permissions safely
DO $$ 
BEGIN
  -- Grant basic permissions
  GRANT USAGE ON SCHEMA public TO authenticated;
  
  -- Grant permissions on interactions table if it exists
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'interactions') THEN
    GRANT ALL ON interactions TO authenticated;
  END IF;
  
  -- Grant execute permissions on functions
  GRANT EXECUTE ON FUNCTION increment_thought_views(uuid) TO authenticated;
  GRANT EXECUTE ON FUNCTION toggle_thought_like(uuid, uuid) TO authenticated;
  GRANT EXECUTE ON FUNCTION increment_thought_shares(uuid) TO authenticated;
  GRANT EXECUTE ON FUNCTION update_user_presence(text, text) TO authenticated;
  GRANT EXECUTE ON FUNCTION get_thought_stats(uuid) TO authenticated;
END $$;