-- Create missing tables and fix schema issues

-- Create thoughts table if it doesn't exist
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'thoughts') THEN
    CREATE TABLE thoughts (
      id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
      title text,
      content text NOT NULL,
      category_id bigint,
      is_public boolean DEFAULT true,
      tags text[] DEFAULT '{}',
      created_at timestamptz DEFAULT now(),
      updated_at timestamptz DEFAULT now(),
      likes_count integer DEFAULT 0,
      views_count integer DEFAULT 0,
      shares_count integer DEFAULT 0
    );
    
    -- Enable RLS on thoughts table
    ALTER TABLE thoughts ENABLE ROW LEVEL SECURITY;
    
    -- Create policies for thoughts
    CREATE POLICY "Public thoughts viewable by everyone" ON thoughts
      FOR SELECT TO public
      USING (is_public = true);
      
    CREATE POLICY "Users can view own private thoughts" ON thoughts
      FOR SELECT TO public
      USING (auth.uid() = user_id);
      
    CREATE POLICY "Users can insert own thoughts" ON thoughts
      FOR INSERT TO public
      WITH CHECK (auth.uid() = user_id);
      
    CREATE POLICY "Users can update own thoughts" ON thoughts
      FOR UPDATE TO public
      USING (auth.uid() = user_id);
      
    CREATE POLICY "Users can delete own thoughts" ON thoughts
      FOR DELETE TO public
      USING (auth.uid() = user_id);
      
    -- Create indexes for thoughts
    CREATE INDEX idx_thoughts_likes_count ON thoughts(likes_count);
    CREATE INDEX idx_thoughts_views_count ON thoughts(views_count);
    CREATE INDEX idx_thoughts_shares_count ON thoughts(shares_count);
  END IF;
END $$;

-- Create categories table if it doesn't exist
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'categories') THEN
    CREATE TABLE categories (
      id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      name text NOT NULL UNIQUE,
      description text,
      color text DEFAULT '#6366f1',
      created_at timestamptz DEFAULT now()
    );
    
    -- Enable RLS on categories table
    ALTER TABLE categories ENABLE ROW LEVEL SECURITY;
    
    -- Create policy for categories
    CREATE POLICY "Categories viewable by everyone" ON categories
      FOR SELECT TO public
      USING (true);
      
    -- Insert default categories
    INSERT INTO categories (name, description, color) VALUES
      ('Existence', 'Deep thoughts about being and reality', '#9333ea'),
      ('Time', 'Temporal paradoxes and time perception', '#3b82f6'),
      ('Consciousness', 'Mind, awareness, and perception', '#ec4899'),
      ('Society', 'Human behavior and social constructs', '#10b981'),
      ('Technology', 'Digital age observations and tech philosophy', '#06b6d4'),
      ('Nature', 'Natural world and environmental thoughts', '#059669'),
      ('Language', 'Words, communication, and meaning', '#f97316'),
      ('Science', 'Scientific concepts and discoveries', '#4f46e5'),
      ('Everyday Life', 'Common experiences and daily observations', '#eab308'),
      ('Abstract', 'Conceptual and theoretical ideas', '#8b5cf6');
  END IF;
END $$;

-- Create profiles table if it doesn't exist
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'profiles') THEN
    CREATE TABLE profiles (
      id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
      username text NOT NULL UNIQUE,
      full_name text,
      avatar_url text,
      created_at timestamptz DEFAULT now()
    );
    
    -- Enable RLS on profiles table
    ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
    
    -- Create policies for profiles
    CREATE POLICY "Public profiles viewable by everyone" ON profiles
      FOR SELECT TO public
      USING (true);
      
    CREATE POLICY "Users can insert own profile" ON profiles
      FOR INSERT TO public
      WITH CHECK (auth.uid() = id);
      
    CREATE POLICY "Users can update own profile" ON profiles
      FOR UPDATE TO public
      USING (auth.uid() = id);
  END IF;
END $$;

-- Create favorites table if it doesn't exist
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'favorites') THEN
    CREATE TABLE favorites (
      id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
      thought_id bigint REFERENCES thoughts(id) ON DELETE CASCADE,
      created_at timestamptz DEFAULT now(),
      UNIQUE(user_id, thought_id)
    );
    
    -- Enable RLS on favorites table
    ALTER TABLE favorites ENABLE ROW LEVEL SECURITY;
    
    -- Create policies for favorites
    CREATE POLICY "Users can manage own favorites" ON favorites
      FOR ALL TO public
      USING (auth.uid() = user_id);
      
    CREATE POLICY "Users can view own favorites" ON favorites
      FOR SELECT TO public
      USING (auth.uid() = user_id);
  END IF;
END $$;

-- Add foreign key from thoughts to categories if it doesn't exist
DO $$ 
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'thoughts_category_id_fkey' 
    AND table_name = 'thoughts'
  ) AND EXISTS (
    SELECT 1 FROM information_schema.tables 
    WHERE table_name = 'thoughts'
  ) AND EXISTS (
    SELECT 1 FROM information_schema.tables 
    WHERE table_name = 'categories'
  ) THEN
    ALTER TABLE thoughts 
    ADD CONSTRAINT thoughts_category_id_fkey 
    FOREIGN KEY (category_id) REFERENCES categories(id);
  END IF;
END $$;

-- Create updated_at trigger function if it doesn't exist
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at trigger to thoughts table
DO $$ 
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.tables 
    WHERE table_name = 'thoughts'
  ) AND NOT EXISTS (
    SELECT 1 FROM information_schema.triggers 
    WHERE trigger_name = 'update_thoughts_updated_at' 
    AND event_object_table = 'thoughts'
  ) THEN
    CREATE TRIGGER update_thoughts_updated_at
    BEFORE UPDATE ON thoughts
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
  END IF;
END $$;

-- Create comments table if it doesn't exist
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'comments') THEN
    CREATE TABLE comments (
      id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
      thought_id bigint NOT NULL,
      user_id uuid NOT NULL,
      content text NOT NULL,
      parent_id uuid,
      likes_count integer DEFAULT 0,
      created_at timestamptz DEFAULT now(),
      updated_at timestamptz DEFAULT now()
    );
    
    -- Enable RLS on comments table
    ALTER TABLE comments ENABLE ROW LEVEL SECURITY;
    
    -- Create policies for comments
    CREATE POLICY "Comments viewable by everyone" ON comments
      FOR SELECT TO public
      USING (true);
      
    CREATE POLICY "Users can insert own comments" ON comments
      FOR INSERT TO public
      WITH CHECK (auth.uid() = user_id);
      
    CREATE POLICY "Users can update own comments" ON comments
      FOR UPDATE TO public
      USING (auth.uid() = user_id);
      
    CREATE POLICY "Users can delete own comments" ON comments
      FOR DELETE TO public
      USING (auth.uid() = user_id);
      
    -- Add foreign keys
    ALTER TABLE comments ADD CONSTRAINT comments_thought_id_fkey
      FOREIGN KEY (thought_id) REFERENCES thoughts(id) ON DELETE CASCADE;
      
    ALTER TABLE comments ADD CONSTRAINT comments_user_id_fkey
      FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;
      
    ALTER TABLE comments ADD CONSTRAINT comments_parent_id_fkey
      FOREIGN KEY (parent_id) REFERENCES comments(id) ON DELETE CASCADE;
      
    -- Add updated_at trigger
    CREATE TRIGGER update_comments_updated_at
    BEFORE UPDATE ON comments
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
    
    -- Create indexes
    CREATE INDEX idx_comments_thought_id ON comments(thought_id);
    CREATE INDEX idx_comments_user_id ON comments(user_id);
    CREATE INDEX idx_comments_parent_id ON comments(parent_id);
    CREATE INDEX idx_comments_created_at ON comments(created_at DESC);
  END IF;
END $$;

-- Grant necessary permissions
DO $$ 
BEGIN
  -- Grant basic permissions
  GRANT USAGE ON SCHEMA public TO authenticated;
  GRANT USAGE ON SCHEMA public TO anon;
  
  -- Grant permissions on tables
  GRANT ALL ON thoughts TO authenticated;
  GRANT SELECT ON thoughts TO anon;
  
  GRANT SELECT ON categories TO authenticated;
  GRANT SELECT ON categories TO anon;
  
  GRANT ALL ON profiles TO authenticated;
  GRANT SELECT ON profiles TO anon;
  
  GRANT ALL ON favorites TO authenticated;
  
  GRANT ALL ON comments TO authenticated;
  GRANT SELECT ON comments TO anon;
  
  -- Grant permissions on sequences
  GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO authenticated;
END $$;