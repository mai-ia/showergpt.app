/*
  # Database Schema Alignment Fix

  This migration fixes critical schema mismatches between the application code and database:

  ## Changes Made:
  1. **Add Missing Columns to shower_thoughts**
     - `views_count` (integer) - Track thought views
     - `likes_count` (integer) - Track thought likes  
     - `shares_count` (integer) - Track thought shares
     - `category` (text) - Categorize thoughts
     - `tags` (text[]) - Tag thoughts with keywords

  2. **Create Missing Database Functions**
     - `increment_thought_views()` - Safely increment view count
     - `toggle_thought_like()` - Toggle like status for users
     - `update_user_presence()` - Track online user presence

  3. **Add Missing Indexes**
     - Performance indexes for frequently queried columns
     - Composite indexes for complex queries

  4. **Create Missing Tables**
     - `interactions` table for tracking user interactions
     - Proper foreign key relationships

  ## Security
  - All functions use SECURITY DEFINER for proper RLS
  - Row Level Security policies maintained
  - Proper error handling in functions
*/

-- Add missing columns to shower_thoughts table
ALTER TABLE shower_thoughts ADD COLUMN IF NOT EXISTS views_count integer DEFAULT 0;
ALTER TABLE shower_thoughts ADD COLUMN IF NOT EXISTS likes_count integer DEFAULT 0;
ALTER TABLE shower_thoughts ADD COLUMN IF NOT EXISTS shares_count integer DEFAULT 0;
ALTER TABLE shower_thoughts ADD COLUMN IF NOT EXISTS category text;
ALTER TABLE shower_thoughts ADD COLUMN IF NOT EXISTS tags text[] DEFAULT '{}';

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_shower_thoughts_views_count ON shower_thoughts(views_count DESC);
CREATE INDEX IF NOT EXISTS idx_shower_thoughts_likes_count ON shower_thoughts(likes_count DESC);
CREATE INDEX IF NOT EXISTS idx_shower_thoughts_category ON shower_thoughts(category);
CREATE INDEX IF NOT EXISTS idx_shower_thoughts_tags ON shower_thoughts USING GIN(tags);

-- Create interactions table if it doesn't exist (for proper like tracking)
CREATE TABLE IF NOT EXISTS interactions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  thought_id uuid REFERENCES shower_thoughts(id) ON DELETE CASCADE,
  interaction_type text NOT NULL CHECK (interaction_type IN ('like', 'view', 'share')),
  created_at timestamptz DEFAULT now(),
  UNIQUE(user_id, thought_id, interaction_type)
);

-- Enable RLS on interactions table
ALTER TABLE interactions ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for interactions
CREATE POLICY "Users can manage own interactions" ON interactions
  FOR ALL TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can view public interactions" ON interactions
  FOR SELECT TO authenticated
  USING (true);

-- Add indexes for interactions
CREATE INDEX IF NOT EXISTS idx_interactions_user_id ON interactions(user_id);
CREATE INDEX IF NOT EXISTS idx_interactions_thought_id ON interactions(thought_id);
CREATE INDEX IF NOT EXISTS idx_interactions_type ON interactions(interaction_type);

-- Create function to increment thought views
CREATE OR REPLACE FUNCTION increment_thought_views(thought_id uuid)
RETURNS integer AS $$
DECLARE
  new_count integer;
  current_user_id uuid;
BEGIN
  -- Get current user ID
  current_user_id := auth.uid();
  
  -- Insert or update view interaction
  INSERT INTO interactions (user_id, thought_id, interaction_type)
  VALUES (current_user_id, thought_id, 'view')
  ON CONFLICT (user_id, thought_id, interaction_type) 
  DO UPDATE SET created_at = now();
  
  -- Update the views count in shower_thoughts
  UPDATE shower_thoughts 
  SET views_count = COALESCE(views_count, 0) + 1
  WHERE id = thought_id
  RETURNING views_count INTO new_count;
  
  RETURN COALESCE(new_count, 0);
EXCEPTION
  WHEN OTHERS THEN
    -- If there's an error, just return current count
    SELECT COALESCE(views_count, 0) INTO new_count
    FROM shower_thoughts 
    WHERE id = thought_id;
    
    RETURN COALESCE(new_count, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to toggle thought likes
CREATE OR REPLACE FUNCTION toggle_thought_like(thought_id uuid, user_id uuid)
RETURNS integer AS $$
DECLARE
  new_count integer;
  interaction_exists boolean;
BEGIN
  -- Check if user has already liked this thought
  SELECT EXISTS(
    SELECT 1 FROM interactions 
    WHERE interactions.user_id = toggle_thought_like.user_id 
    AND interactions.thought_id = toggle_thought_like.thought_id 
    AND interaction_type = 'like'
  ) INTO interaction_exists;
  
  IF interaction_exists THEN
    -- Remove like
    DELETE FROM interactions 
    WHERE interactions.user_id = toggle_thought_like.user_id 
    AND interactions.thought_id = toggle_thought_like.thought_id 
    AND interaction_type = 'like';
    
    -- Decrement likes count
    UPDATE shower_thoughts 
    SET likes_count = GREATEST(COALESCE(likes_count, 0) - 1, 0)
    WHERE id = thought_id
    RETURNING likes_count INTO new_count;
  ELSE
    -- Add like
    INSERT INTO interactions (user_id, thought_id, interaction_type)
    VALUES (user_id, thought_id, 'like');
    
    -- Increment likes count
    UPDATE shower_thoughts 
    SET likes_count = COALESCE(likes_count, 0) + 1
    WHERE id = thought_id
    RETURNING likes_count INTO new_count;
  END IF;
  
  RETURN COALESCE(new_count, 0);
EXCEPTION
  WHEN OTHERS THEN
    -- If there's an error, just return current count
    SELECT COALESCE(likes_count, 0) INTO new_count
    FROM shower_thoughts 
    WHERE id = thought_id;
    
    RETURN COALESCE(new_count, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to increment shares
CREATE OR REPLACE FUNCTION increment_thought_shares(thought_id uuid)
RETURNS integer AS $$
DECLARE
  new_count integer;
  current_user_id uuid;
BEGIN
  -- Get current user ID
  current_user_id := auth.uid();
  
  -- Insert share interaction
  INSERT INTO interactions (user_id, thought_id, interaction_type)
  VALUES (current_user_id, thought_id, 'share')
  ON CONFLICT (user_id, thought_id, interaction_type) 
  DO UPDATE SET created_at = now();
  
  -- Update the shares count in shower_thoughts
  UPDATE shower_thoughts 
  SET shares_count = COALESCE(shares_count, 0) + 1
  WHERE id = thought_id
  RETURNING shares_count INTO new_count;
  
  RETURN COALESCE(new_count, 0);
EXCEPTION
  WHEN OTHERS THEN
    -- If there's an error, just return current count
    SELECT COALESCE(shares_count, 0) INTO new_count
    FROM shower_thoughts 
    WHERE id = thought_id;
    
    RETURN COALESCE(new_count, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to update user presence (for realtime features)
CREATE OR REPLACE FUNCTION update_user_presence(
  presence_status text DEFAULT 'online',
  page_location text DEFAULT '/'
)
RETURNS void AS $$
DECLARE
  current_user_id uuid;
BEGIN
  -- Get current user ID
  current_user_id := auth.uid();
  
  IF current_user_id IS NULL THEN
    RETURN;
  END IF;
  
  -- Update or insert user presence
  INSERT INTO online_users (user_id, status, current_page, last_seen, updated_at)
  VALUES (current_user_id, presence_status, page_location, now(), now())
  ON CONFLICT (user_id) 
  DO UPDATE SET 
    status = EXCLUDED.status,
    current_page = EXCLUDED.current_page,
    last_seen = now(),
    updated_at = now();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to get thought statistics
CREATE OR REPLACE FUNCTION get_thought_stats(thought_id uuid)
RETURNS TABLE(
  views_count integer,
  likes_count integer,
  shares_count integer,
  comments_count integer
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(st.views_count, 0) as views_count,
    COALESCE(st.likes_count, 0) as likes_count,
    COALESCE(st.shares_count, 0) as shares_count,
    COALESCE((
      SELECT COUNT(*)::integer 
      FROM comments 
      WHERE comments.thought_id = get_thought_stats.thought_id
    ), 0) as comments_count
  FROM shower_thoughts st
  WHERE st.id = get_thought_stats.thought_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update existing shower_thoughts to have proper default values
UPDATE shower_thoughts 
SET 
  views_count = COALESCE(views_count, 0),
  likes_count = COALESCE(likes_count, 0),
  shares_count = COALESCE(shares_count, 0),
  tags = COALESCE(tags, '{}')
WHERE views_count IS NULL 
   OR likes_count IS NULL 
   OR shares_count IS NULL 
   OR tags IS NULL;

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON interactions TO authenticated;
GRANT EXECUTE ON FUNCTION increment_thought_views(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION toggle_thought_like(uuid, uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION increment_thought_shares(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION update_user_presence(text, text) TO authenticated;
GRANT EXECUTE ON FUNCTION get_thought_stats(uuid) TO authenticated;